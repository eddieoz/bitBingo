---
description: 
globs: 
alwaysApply: false
---
**Prompt for Creating Unit Tests with a BDD Approach**

You are an expert in TypeScript, React (Next.js), Expo (React Native), Tamagui, Supabase, Zod, and a broad set of modern frontend/backends tools. Your task is to create **unit tests** following **Behavior-Driven Development (BDD)** principles, ensuring the tests are highly readable, self-documenting, and reflect the expected behaviors of the components or modules under test.

Below are the **key rules and guidelines** for writing these tests:

---

### General Testing Guidelines

1. **Behavior-Driven Development (BDD) Style**  
   - Write your tests using clear `describe`, `it`, and `expect` statements (or equivalent BDD syntax from your chosen testing framework).
   - Focus on user stories or behavior specifications, ensuring test names describe the **intended behavior** rather than implementation details.
   - For complex flows, consider specifying **Given/When/Then** steps in comments or using a BDD-friendly library.

2. **Technology Stack Constraints**  
   - Use **TypeScript** strictly; avoid `any` and aim for strong typing.
   - For React-based tests (web) use **React Testing Library** (and `@testing-library/react`).
   - For React Native tests, use **React Native Testing Library** with BDD style as appropriate.
   - Ensure all code and test files follow the **TypeScript** code style and structure detailed in the project’s rules.

3. **Test Structure**  
   - Keep each test suite **small and focused**—test one module, component, or piece of functionality at a time.
   - Describe the context in `describe()` blocks, and use `it()` to assert expected outcomes.
   - Use **concise** and **readable** naming for tests and utility test functions. For example, `it('should display error if email is invalid')`.

4. **Error Handling and Edge Cases**  
   - Always include tests for **error states** and edge cases.
   - Write BDD scenarios like:  
     ```ts
     it('should show an error message when an invalid input is provided', () => {
       // Given: user is on the registration page
       // When: user submits an invalid email
       // Then: it should display an error message
     });
     ```

5. **Integration with Zod**  
   - When testing form inputs or data schemas, validate shapes with **Zod** in your tests to ensure correct data handling.
   - If the function or component relies on a Zod schema, test valid/invalid scenarios explicitly.

6. **Project-Specific Conventions**  
   - Structure test files alongside their implementations or in a dedicated `__tests__` directory (depending on your team’s convention).
   - Follow the monorepo standards (using Turbo) if you are testing packages within a monorepo.
   - For Next.js projects, place tests near the relevant `app` or `components` folder to maintain clarity.

7. **UI and State Management Concerns**  
   - If testing a **React component** using Zustand or React Context + useReducer, focus on the component’s BDD perspective (e.g., “When the user clicks on the button, it increments the counter by 1”).
   - Mock external APIs/services (e.g., Supabase or Stripe) to avoid network calls during tests.

8. **Internationalization (i18next / react-i18next)**  
   - If relevant, test that components render correct translations based on the user’s locale.
   - For components containing text, ensure the test includes verifying the localized string is displayed.

9. **Performance and Security**  
   - Although not the primary focus of unit tests, ensure significant security checks or performance bottlenecks are tested when relevant. For example, test that secret tokens are **not** logged or exposed in the UI.

10. **Output and Review**  
   - Provide **clear, concise** code snippets and ensure they are production-ready.
   - Include minimal but sufficient comments describing the scenario (Given/When/Then).
   - After writing or updating tests, **run the build** (`pnpm build`) to confirm there are no errors and that code coverage meets the project’s standards.

---

### Example BDD Test Snippet (React):

```ts
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect } from 'vitest'; // or Jest
import { EmailForm } from '@/frontend/components/EmailForm';

describe('EmailForm Component', () => {
  it('should display a success message when a valid email is submitted', async () => {
    // Given: The component is rendered
    render(<EmailForm />);

    // When: The user types a valid email and clicks submit
    fireEvent.change(screen.getByLabelText(/email/i), {
      target: { value: 'test@example.com' },
    });
    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    // Then: The success message should appear
    expect(await screen.findByText(/email submitted successfully/i)).toBeInTheDocument();
  });

  it('should show an error message when an invalid email is submitted', async () => {
    // Given: The component is rendered
    render(<EmailForm />);

    // When: The user types an invalid email and clicks submit
    fireEvent.change(screen.getByLabelText(/email/i), {
      target: { value: 'invalid-email' },
    });
    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    // Then: The error message is displayed
    expect(await screen.findByText(/invalid email address/i)).toBeInTheDocument();
  });
});
```

> **Note**: This is a simplified example. Ensure you apply **Zod** validation and any relevant BDD libraries or patterns as needed. Also, incorporate your real project’s code style (e.g., how you import or configure testing libraries) and existing monorepo structure.

---

### Final Instruction

Use the details and conventions above to write **high-quality BDD-style unit tests** that cover critical paths, handle error states, and accurately reflect the **intended behavior** of each component or function. Ensure tests run smoothly alongside the existing build process (`pnpm build`), follow the stated code style, and adhere to all TypeScript, Next.js, and project-specific rules.

**Output**: Provide the complete test code (and any additional helper code) with clear BDD naming and structure. Strive for **concise** yet **comprehensive** tests that communicate the component or function’s behavior to any developer reading them.

