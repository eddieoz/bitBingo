# BitBingo Verification Process

This document explains how anyone can independently verify the fairness and outcome of any bitBingo game using only public data and open-source logic.

## Deterministic Game Logic

- **All randomness** (card generation, number draws) is derived from the Bitcoin block hash of the confirmed transaction anchoring the game.
- **BIP32 HD key derivation** is used with the block hash (SHA-256) as the seed, and the path `m/44'/0'/0'/0/{index}` for each card or draw.
- **Card grids** are generated from the derived public key (see below).
- **Drawn numbers** are generated by taking the last 4 bytes of the derived public key, converting to an integer, and mapping to 1–75.

## Card Generation Verification

1. **Obtain Inputs:**
   - The Bitcoin transaction ID (TXID) for the game.
   - The participant CSV (from IPFS, using the CID in the OP_RETURN of the TX).
   - The block hash of the block containing the TX (from any block explorer).
2. **Calculate the seed:**
   - Compute the SHA-256 hash of the block hash (hex string). This is the seed for BIP32.
3. **Find the participant's line index** in the CSV (0-based, after the header row).
4. **Derive the public key** using BIP32 with the seed and path `m/44'/0'/0'/0/{lineIndex}`.
5. **Generate the card grid:**
   - Convert the public key to hex.
   - Hash the hex string with SHA-256.
   - Use bytes from the hash to select unique numbers for each column (B: 1–15, I: 16–30, N: 31–45, G: 46–60, O: 61–75), skipping the center square (N[2], which is always free/null).
   - The card ID is `card-{last 8 hex characters of publicKeyHex}`.
6. **Compare** the generated card to the one shown in the app.

## Number Drawing Verification

1. **Obtain Inputs:**
   - The block hash (as above).
   - The sequence of drawn numbers (from the app or API).
2. **For each draw index (starting at 0):**
   - Derive the public key at path `m/44'/0'/0'/0/{drawIndex}`.
   - Take the last 4 bytes of the public key buffer, convert to a 32-bit unsigned integer (big endian).
   - Compute `(value % 75) + 1` to get the bingo number.
   - If the number is already drawn, increment the index and repeat until a unique number is found.
3. **Repeat** until the drawn sequence matches the app's output.

## Winner Verification

1. **Obtain the winner's card(s)** (as above).
2. **Obtain the drawn number sequence** (as above).
3. **Check for Bingo:**
   - A win requires 5 marked squares in a row, column, or diagonal (center is always free).
   - Compare the card grid and drawn numbers to confirm the win.

## Partial/Full Win Modes

- If the game is in partialAndFull mode, the game may end after a partial win (e.g., line bingo) or continue to full card.
- The API exposes the current state, including whether a partial win has occurred, who the winners are, and if the game is over.

## Tools for Manual Verification

- [Ian Coleman BIP39 Tool](https://iancoleman.io/bip39/):
  - Use the SHA-256 of the block hash as the BIP32 seed.
  - Set the derivation path as above.
  - Use the derived public key for card/number generation.
- Online hex-to-string and hash calculators for manual steps.

## Example

1. Get the TXID and block hash from a block explorer.
2. Get the participant CSV from IPFS (using the CID in the OP_RETURN output).
3. For a given player, find their line index, derive their card, and verify the grid.
4. For number draws, derive each public key, compute the number, and verify the sequence.

## See Also
- [docs/how-to-use.md](how-to-use.md) for user/admin workflow
- [server/utils.js](../server/utils.js) for the exact implementation logic 